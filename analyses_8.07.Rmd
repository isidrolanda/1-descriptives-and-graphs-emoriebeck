---
title: "Personality Behind Bars"
date: "8/7/2017"
output:
  pdf_document:
    number_sections: yes
    toc: yes
    toc_depth: 2
    includes:
            in_header:
                header.tex
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = F, warning=F)
```

#Workspace
##Packages

```{r}
library(plyr)
library(tidyverse)
library(survey)
library(mi)
library(mitools)
library(psych)
library(googlesheets)
library(twang)
library(lme4)
library(gridExtra)
library(xtable)
```

##Working Directory
```{r}
data_path <- "~/Dropbox (Brown)/The Clink"
```


##Load Data
First, we will lead in a Google Sheet that indexes original variable names in the NLSY 1979 Child and Young Adults Sample as well as the original NLSY Sample of their mothers. The Sheet also contains rules splitting variables by type (matching variables, predictor variables, grouping variables, and outcome variables) as well as rules for compositing variables and their original scale.  
```{r}
# load google sheet containing variable names, recoding, etc #
dat <- gs_title("NLSY79_ChildYA_MI_PSM") 
# create a meta file for downloading the child data
dat %>% gs_read(ws = "Child") %>% select(`QName`, year) %>%
  write_delim(path = paste(data_path, "meta.CHILDYA", sep = "/"), delim = ",", col_names = F)
# create a meta file for downloading the mother data
dat %>% gs_read(ws = "Mom") %>% select(`QName`, year) %>%
  write_delim(path = paste(data_path, "meta.NLSY79", sep = "/"), delim = ",", col_names = F)

# grab the child and mother data of variables chosen to include 
child <- dat %>% gs_read(ws = "Child") %>% filter(Include == "Yes")
mom <-   dat %>% gs_read(ws = "Mom")   %>% filter(Include == "Yes")

# load in the Rdata files of the raw, uncleaned NLSY data sets
load(paste(data_path, "/data/nlsy79cya/nlsy79cya.RData", sep = "/"))
load(paste(data_path, "data/nlsy79/nlsy79moms.RData", sep = "/"))

# cut additional variables not included in the present analyses
new_data <- tbl_df(new_data) %>% select(one_of(child$RNUM))
mom_data <- tbl_df(mom_data) %>% select(one_of(mom$RNUM))

# get IDs of the moms to match with children
moms <- unique((new_data %>% 
  select(C0000100, C0000200) %>%
  setNames(c("PROC_CID", "PROC_MID")))$PROC_CID)
# get IDs of the children
part_ids <- new_data %>% 
  select(C0000100, C0000200, C0005700, C0005400) %>%
  setNames(c("PROC_CID", "PROC_MID", "Dem_DOBYear", "DemCSex")) %>%
  filter(!is.na(PROC_CID) & !is.na(PROC_MID))
# find moms with children
moms <- unique(part_ids$PROC_MID)

load(paste(data_path, "data/all_data2.RData", sep = "/"))
```

#Data Cleaning
##Match Items
Match items are those items that we will use to match individuals on.
###Mom Data
```{r, eval = F}
# get vector of original reference numbers (column names) of the mom data
mom_long_cols <- (mom %>% filter(!is.na(Rule.Age)))$RNUM
# get vector of the new variable names of the mom data
mom_new_cols <- (mom %>% filter(!is.na(Rule.Age)))$comb_varname

mom_long <- mom_data %>% 
  filter(R0000100 %in% moms) %>%
  select(R0000100, one_of(mom_long_cols)) %>%               # select ID, DOB, and items for compositing
  gather(key = item, value = value, one_of(mom_long_cols)) %>% # switch to long format
  setNames(c("PROC_MID", "item", "value")) %>% # rename columns
  full_join(part_ids) %>% # add participant IDs
  mutate(item = mapvalues(item, mom_long_cols, mom_new_cols),
         value = ifelse(grepl("MJail_MRes", item) == T & value == 5, 1,
                 ifelse(grepl("MJail_MRes", item) == T & !is.na(value) == T, 0, 
                 ifelse(grepl("MJail_MRes", item) == F, value, NA)))) %>% # recode items to to new names
  left_join((mom %>% # add in rules for compositing and reverse coding
               select(comb_varname, Rule.Age, Rule.Item, reverse_code) %>% 
               filter(comb_varname %in% mom_new_cols) %>% 
               rename(item = comb_varname))) 
```

###Child / YA Data
```{r, eval = F}
# create a small function for calculating the mode
Mode <- function(x) {
  ux <- unique(x)
  ux <- ux[!is.na(ux)]
  ux[which.max(tabulate(match(x, ux)))]
}
# get vector of original reference numbers (column names) of the child data with multiple waves
child_long_cols <- (child %>% filter(year != "XRND" & var.type == "match"))$RNUM
# get vector of the new variable names of the child data with multiple waves
child_new_cols <- (child %>% filter(year != "XRND" & var.type == "match"))$comb_varname

match_long <- new_data %>%
  # select ID, DOB, and items for compositing
  select(C0000100, C0000200, C0005700, C0005400, one_of(child_long_cols)) %>%               
  gather(key = item, value = value, one_of(child_long_cols)) %>% # switch to long format
  setNames(c("PROC_CID", "PROC_MID", "Dem_DOBYear", "DemCSex", "item", "value")) %>% # rename columns
  mutate(item = mapvalues(item, child_long_cols, child_new_cols)) %>% # recode items to to new names
  left_join((child %>% 
               select(comb_varname, Rule.Age, Rule.Item, reverse_code) %>% # add in rules for 
               filter(comb_varname %in% child_new_cols) %>% # compositing and reverse coding
               rename(item = comb_varname))) %>%
  full_join((mom_long)) %>%
  separate(item, c("item", "year"), sep = "[.]") %>% # split items in item and year columns
  mutate(year = as.numeric(year), # convert year to numeric
         age = ifelse(!is.na(value) & year >= Dem_DOBYear, 
                      year - Dem_DOBYear, NA))  # calculate age

match_long2 <- match_long %>%   
  full_join(match_long %>%
      filter(grepl("HlthCndLimChck", item)) %>%
      select(-item, -Rule.Age, -Rule.Item, -reverse_code) %>%
      rename(hlthChck = value)) %>%
  mutate(value = ifelse(grepl("HlthCndLim_", item) == T & is.na(value) == T, hlthChck, value)) %>%
   # get rid of cases where we don't have an age or don't have a value / response
  filter((!is.na(age) | !is.na(value)) & (age <= 14 | item == "HHJail_HHJail")) %>%                                          
  mutate(value = ifelse(grepl("UsualRes", item) == T, 
                        mapvalues(value, seq(1,12,1), c(1, rep(0, 11))), # 1 = with mother; 2 = otherwise
                 ifelse(grepl("Limit", item) == T, 
                        mapvalues(value, seq(3,0,-1), seq(0,3,1)), # reverse weird scale for Limiting / Structure
                 ifelse(grepl("HrTV", item) == T, value/100, 
                 ifelse(grepl("HlthCndLim", item) == T & !is.na(value) == T & value != 0, 1, 
                 ifelse(grepl("HlthCndLimScl", item) == T & year %in% seq(1986, 2004,2), 
                        mapvalues(value, seq(0,2,1), c(0,1,0)), 
                 ifelse(grepl("EduRemed", item) == T & year %in% seq(1988,1998,2), 
                        mapvalues(value, c(0,1,2,4), c(0,1,0,0)), 
                 ifelse(item == "HlthCndReqTr12mo_HlthCndReqTr12mo", 
                        mapvalues(value, seq(0,2,1), c(0,1,NA)), 
                 ifelse(item == "DemFathNHH_FathNHH", 
                        mapvalues(value, 1:4, c(1:3,1)), 
                 ifelse(grepl("Mom2Dad", item) == T, 
                        mapvalues(value, seq(1,13,1), c(1, rep(0,12))), 
                 ifelse(grepl("FathGrade", item) == T, 
                        mapvalues(value, c(seq(0,20,1),95), c(seq(0,20,1),NA)), 
                 ifelse(grepl("Home", item) == T & value > 99, 99, 
                 ifelse(grepl("NghdSf2Scl", item) == T, 
                        mapvalues(value, c(seq(1,4,1), 6, 25), c(seq(1,4,1), NA, NA)), 
                        value))))))))))))) %>%          #Recode weird time variable where 100 = 1 hr to 1 hr = 1 hr
  group_by(item) %>%
  mutate(min = min(value, na.rm = T), max = max(value, na.rm = T),                  # find min & max for reverse scoring
         value = ifelse(reverse_code != "rev", value,                               # leave pos keyed items alone
                        reverse.code(-1, value, mini = min[1], maxi = max[1]))) %>% # reverse code neg keyed items
  select(-min, -max) # get rid of min and max columns



seq_years <- seq(1988,1992, 2)
# create a sum variable for mom's response to tantrums #
match_long3 <- match_long2 %>%
  filter(grepl("DSTantrum", item) == T) %>%
  mutate(value = ifelse(grepl("DSTantrum", item) == T, 
                 ifelse(year %in% seq_years & is.na(value) == F, 1, # different selected events in 88-92 coded as 1-7
                 ifelse(year %in% seq_years & is.na(value) == T, 0, # unselected events not coded
                 ifelse(year == 1996, recode(value, `2` = 0), 
                 ifelse(grepl("Talk", item) == T, recode(value, `1` = 0, `0` = 1),
                        value)))), value)) %>%
  group_by(PROC_CID, PROC_MID, age, item, Rule.Age, Rule.Item) %>%
  summarize(value = max(value, na.rm = T), # some mothers filled out 6-9 and 10+ surveys in one year
            value = ifelse(is.infinite(value) == T, NA, value)) %>%  
  group_by(PROC_CID, PROC_MID, age, Rule.Age, Rule.Item) %>% # compositing across different responses
  summarize(value = sum(value, na.rm = T),
            item = "MRTantrum_Tantrum") %>%
  # add in health data
  full_join(match_long2 %>% filter(grepl("HlthCndLim_", item)) %>%
              group_by(PROC_CID, PROC_MID, age, year, item, Rule.Age, Rule.Item) %>%
              # average across unique items for the same age first
              summarize(value = mean(value)) %>%
              separate(item, c("type", "item")) %>%
              group_by(PROC_CID, PROC_MID, age, year, type, Rule.Age, Rule.Item) %>%
              # sum across broader categories of items for the same ages second
              summarize(value = sum(value)) %>%
              mutate(item = paste(type, type, sep = "_"))) %>%
  # add in all other match variables but the health and tantrum variables
  full_join(match_long2 %>% filter(grepl("DSTantrum", item) == F & grepl("HlthCndLim_", item) == F))
  
# create a function for compositing matching variables
sum_fun <- function(df, Rule1, Rule2){
  fun_call <- function(x, rule){
    switch(rule,
           average = mean(x, na.rm = T),
           mode = Mode(x)[1],
           sum = sum(x, na.rm = T),
           select = unique(x)[1],
           max = max(x, na.rm = T))
  }
  df %>%
    group_by(PROC_CID, item, Dem_DOBYear) %>% # group by person and item (collapse across age)
    summarize(value = fun_call(value, Rule1)) %>% # use proper summary function on each group combination
    mutate(value = ifelse(is.nan(value) == T, NA, # get rid of NaN and Inf values
                 ifelse(is.infinite(value) == T, NA, value))) %>%
    separate(item, c("type", "item")) %>% # split item further into category and unique item
    group_by(PROC_CID, type) %>% # group by subject and type (collapse across item)
    summarize(value = fun_call(value, Rule2)) %>% # use proper summary function on each group combination
    mutate(value = ifelse(is.nan(value) == T, NA, # get rid of NaN and Inf values
                 ifelse(is.infinite(value) == T, NA, value))) %>%
    ungroup()
}

child_wide_cols <- (child %>% filter(year == "XRND" & var.type == "match"))$RNUM
child_new_cols <- (child %>% filter(year == "XRND" & var.type == "match"))$comb_varname
child_new_cols <- gsub(".XRND", "", child_new_cols)

# here, we are going to grab the child data with only one response, clean up variables that need to be recoded
# these are intentionally in wide format and will eventually be joined with other data

match_wide <- new_data %>%
  select(C0000100, C0000200, C0005700, C0005400, one_of(child_wide_cols)) %>% # select ID, DOB, and items for compositing
  gather(key = item, value = value, -C0000100, -C0000200, -C0005700, -C0005400) %>% # switch to long format
  setNames(c("PROC_CID", "PROC_MID", "Dem_DOBYear", "DemCSex", "item", "value")) %>% # rename columns
  mutate(item = mapvalues(item, child_wide_cols, child_new_cols)) %>%
  filter(!is.na(value) & !(item %in% c("DemHeightIN", "DemHeightFT", "DemWeightLBS"))) %>%
  mutate(value = ifelse(grepl("MRed", item) == T, mapvalues(value, c(0,1,4), c(0,1,1)), value)) %>%
  separate(item, c("type", "item"), sep = "[_]") %>% # split items in item and year columns
  group_by(PROC_CID, PROC_MID, type, Dem_DOBYear) %>%
  summarize(value = mean(value, na.rm = T)) %>%
  ungroup() %>%
  mutate(value = ifelse(grepl("MRed", type) == T | grepl("Diuret", type) == T, ceiling(value), value)) %>%
  spread(key = type, value = value) %>%
  mutate(DemRace = mapvalues(DemRace, seq(1,3,1), seq(3,1,-1)),
         BreastFed = ifelse(WkBreastFedEnd > WkBreastFedBeg, WkBreastFedEnd - WkBreastFedBeg, NA)) %>%
  select(-WkBreastFedEnd, -WkBreastFedBeg)

# run the summary function created above on the long format cross-time matching variables
match_wide <- match_long3 %>%
  group_by(Rule.Age, Rule.Item) %>% # group by rules because it's faster
  nest() %>% # nest all the data for each rule combination together
  mutate(value = pmap(list(data, Rule.Age, Rule.Item), possibly(sum_fun, NA_real_))) %>% # call the summary function
  unnest(value, .drop = T) %>% # unnest the results
  ungroup() %>%
  select(-contains("Rule")) %>% # get rid of the rule variables
  spread(key = type, value = value) %>% # change to wide format
  mutate(HomeBin = ceiling(HomeBin)) %>% 
  select(-contains("eight")) %>% # get rid of height and weight; we'll take care of those later
  full_join(match_wide) %>% # join with wide format matching variables
  mutate_all(as.numeric) # make sure they are all numeric

## norm height and weight information by age) ##
# height and weight are tricky, so instead of using sometimes unreliable raw height and weight data, we will use 
# the World Health Organization's norms to calculate height-for-age and weight-for-age percentiles
source(paste(data_path, "data/who2007_R/who2007.R", sep = "/"))
htwt <- match_long3 %>% ungroup() %>%
  # grab height and weight variables for 9-10 year olds
  filter(item %in% c("DemHeightFT_HeightFT", "DemHeightIN_HeightIN", "DemWeightLBS_WeightLBS") & age %in% c(9,10)) %>%
  select(PROC_CID, PROC_MID, age, DemCSex, year, item, value) %>%
  group_by(PROC_CID, PROC_MID, age, DemCSex, year, item) %>%
  summarize(value = mean(value, na.rm = T)) %>%
  ungroup() %>%
  spread(key = item, value = value) %>% # change to wide format
  # get rid of implausible height values
  filter(!(DemHeightFT_HeightFT > 5 & DemHeightIN_HeightIN < 12) &
         !is.na(DemHeightIN_HeightIN) & !is.na(DemWeightLBS_WeightLBS) & !is.na(DemHeightFT_HeightFT)) %>%
  # convert weight to kilograms, height to centimeters, and age to months
  mutate(DemWeightKG_WeightKG = DemWeightLBS_WeightLBS/2.2,
         DemHeightIN_HeightIN = ifelse(DemHeightIN_HeightIN < 12 & DemHeightFT_HeightFT < 6, 
                                       DemHeightIN_HeightIN + (DemHeightFT_HeightFT * 12), DemHeightIN_HeightIN),
         DemHeightCM_HeightCM = DemHeightIN_HeightIN * 2.54,
         ageMon = 12*age) %>%
  # catch remaining implausible values
  filter(DemWeightLBS_WeightLBS > 30 & DemHeightIN_HeightIN > 30)

htwt <- data.frame(htwt)
wfawho2007<-read.table(paste(data_path, "data/who2007_R/wfawho2007.txt", sep = "/"), header=T,sep="",skip=0)
hfawho2007<-read.table(paste(data_path, "data/who2007_R/hfawho2007.txt", sep = "/"),header=T,sep="",skip=0)
bfawho2007<-read.table(paste(data_path, "data/who2007_R/bfawho2007.txt", sep = "/"),header=T,sep="",skip=0) 
who2007(FilePath=paste(data_path, "data", sep = "/"),
        FileLab = "nlsy_who", mydf=htwt, sex=DemCSex, age=ageMon, 
        weight=DemWeightKG_WeightKG, height=DemHeightCM_HeightCM)
htwt <- read.csv(paste(data_path, "data/nlsy_who_z.csv", sep = "/"), stringsAsFactors = F)  %>%
  select(PROC_CID, PROC_MID, age, DemCSex, zhfa, zwfa) %>%
  mutate(DemPweight = pnorm(zwfa), DemPheight = pnorm(zhfa)) %>%
  select(-zwfa, -zhfa, -age) %>% ungroup()

# add the height and weight variables to the matching dataset
match_wide <- match_wide %>% left_join(htwt) %>% ungroup()

# get unique subjects in the matching variables
match_subs <- unique(as.character(match_wide$PROC_CID))
```

```{r}
head(match_wide)
```


##Groups
To do propensity score weighting, we need to define our groups - Jail, Court Ordred Community Service, or neither. We are interested in incarceration in adolscence, which we define as ages below 19. Because we do not want our groups to overlap, anyone who was both incarcerated and participated in community service were included in the incarcerated group only.
```{r, eval = F}
# get vector of original reference numbers (column names) of the child data with multiple waves
child_long_cols <- (child %>% filter(year != "XRND" & var.type == "group"))$RNUM
# get vector of the new variable names of the child data with multiple waves
child_new_cols <-  (child %>% filter(year != "XRND" & var.type == "group"))$comb_varname

# create age categories
age_orig <- seq(8, 19, 1)
age_cat <- rep(c(9,10,12,14,16,18), each = 2)

group_long <- new_data %>%
  select(C0000100, C0000200, C0005700, C0005400, one_of(child_long_cols)) %>%
  gather(key = item, value = value, one_of(child_long_cols)) %>%
  setNames(c("PROC_CID", "PROC_MID", "Dem_DOBYear", "DemCSex", "item", "value")) %>% # rename columns
  mutate(item = mapvalues(item, child_long_cols, child_new_cols)) %>%
  separate(item, c("item", "year"), sep = "[.]") %>%
  mutate(year = as.numeric(year), 
         age = ifelse(!is.na(value) & year >= Dem_DOBYear, year - Dem_DOBYear, NA)) %>%
  filter(!is.na(age) & !is.na(value) & age <= 19) %>%
  mutate(age = mapvalues(age, age_orig, age_cat),
         #age = ifelse(age <= 19, "<19", ">19"), 
         value = ifelse(item == "Jail_ResJail",
                        mapvalues(value, seq(1:22), c(rep(0,4), 1, rep(0,17))), value)) %>%
  #unite(item, item, age, sep = ".") %>%
  group_by(PROC_CID, PROC_MID, DemCSex, item, age) %>%
  summarize(value = max(value, na.rm = T)) %>%
  ungroup() %>%
  separate(item, c("type", "item")) %>%
  group_by(PROC_CID, PROC_MID, DemCSex, type) %>%
  summarize(value = max(value), 
            value = ifelse(value != 0, 1,
                    ifelse(is.na(value) == T, NA, 0))) %>%
  ungroup()

group_wide <- group_long %>%
  spread(key = type, value = value) %>%
  mutate_at(vars(Cnsling:Jail), funs(ifelse(is.na(.) == T, 0, .))) %>%
  mutate(CommServ = ifelse(CrtCommServ == 1, 1, 0),
         groups = ifelse(Jail == 1, 1, 
                  ifelse(CommServ == 1, 2,
                  ifelse(Jail == 0 & CommServ == 0, 0, NA))),
         groups = factor(groups, levels = seq(0,2,1), labels = c("None", "Jail", "CommServ")))

group_long %>%
  unite(comb, type, age, sep = "_") %>%
  spread(key = comb, value = value) %>%
  mutate_at(vars(`Cnsling_<19`:`Jail_>19`), funs(ifelse(is.na(.) == T, 0, .))) %>%
  mutate(`CommServ_<19` = ifelse(`CrtCommServ_<19` == 1, 1, 0),
         `CommServ_>19` = ifelse(`CrtCommServ_>19` == 1 & `CrtCommServ_<19` != 1, 1, 0),
         `Jail_>19` = ifelse(`Jail_>19` == 1 & `Jail_<19` == 0, 1, 0),
         `CommServ_<19` = ifelse(`Jail_<19` == 0, `CommServ_<19`, 0),
         `CommServ_>19` = ifelse(`Jail_>19` == 0, `CommServ_>19`, 0)) %>%
  ungroup() %>% 
  mutate(`None_<19` = ifelse(`CommServ_<19` == 0 & `Jail_<19` == 0, 1, 0),
         `None_>19` = ifelse(`CommServ_>19` == 0 & `Jail_>19` == 0, 1, 0)) %>%
  summarize_at(vars(`CommServ_<19`, `CommServ_>19`,  `Jail_<19`, `Jail_>19`, `None_<19`, `None_>19`),funs(sum))
  
group_subs <- unique(as.character(group_wide$PROC_CID))

match_wide <- match_wide %>%
  left_join(group_wide %>% ungroup() %>% select(PROC_CID, groups))
```

```{r}
head(group_wide)
```



##Predictors
We have four predictor/outcomes, whose trajectory over time we will track using growth models. For these, we want data from adolescence, so we choose variables we choose 4 perosnality variables whose data we have throughout the period -- Impulsivity, Sensation Seeking, Self-Esteem, and CESD depression.
```{r, eval = F}
child_long_cols <- (child %>% filter(year != "XRND" & var.type == "predictor"))$RNUM
child_new_cols <-  (child %>% filter(year != "XRND" & var.type == "predictor"))$comb_varname

age_orig <- seq(8, 25, 1)
age_cat <- rep(seq(8,24,2), each = 2)

pred_long <- new_data %>%
  select(C0000100, C0000200, C0005700, C0005400, one_of(child_long_cols)) %>%
  gather(key = item, value = value, one_of(child_long_cols)) %>%
  setNames(c("PROC_CID", "PROC_MID", "Dem_DOBYear", "DemCSex", "item", "value")) %>% # rename columns
  mutate(item = mapvalues(item, child_long_cols, child_new_cols)) %>%
  separate(item, c("item", "year"), sep = "[.]") %>%
  mutate(year = as.numeric(year), 
         age = ifelse(!is.na(value) & year >= Dem_DOBYear, year - Dem_DOBYear, NA)) %>%
  filter(!is.na(age) & !is.na(value) & age <= 25) %>%
  mutate(age = mapvalues(age, age_orig, age_cat)) %>%
  #unite(item, item, age, sep = ".") %>%
  group_by(PROC_CID, item, age) %>%
  summarize(value = mean(value, na.rm = T)) %>%
  ungroup() %>%
  separate(item, c("item", "type")) %>%
  group_by(PROC_CID, item, age) %>%
  summarize(value = mean(value, na.rm = T)) %>%
  ungroup() %>%
  mutate(age0 = age-14)

pred_subs <- unique(as.character(pred_long$PROC_CID))
```

```{r}
head(pred_long)
```



##Moderators


##Outcomes
```{r, eval = F}
child_long_cols <- (child %>% filter(year != "XRND" & var.type == "outcome"))$RNUM
child_new_cols <-  (child %>% filter(year != "XRND" & var.type == "outcome"))$comb_varname

age_orig <- seq(6, 25, 1)
age_cat <- rep(seq(6,24,2), each = 2)

outcome_long <- new_data %>%
  select(C0000100, C0000200, C0005700, one_of(child_long_cols)) %>%
  gather(key = item, value = value, one_of(child_long_cols)) %>%
  setNames(c("PROC_CID", "PROC_MID", "Dem_DOBYear", "item", "value")) %>%
  mutate(item = mapvalues(item, child_long_cols, child_new_cols)) %>%
  separate(item, c("item", "year"), sep = "[.]") %>%
  mutate(year = as.numeric(year), 
         age = ifelse(!is.na(value) & year >= Dem_DOBYear, year - Dem_DOBYear, NA)) %>%
  filter(!is.na(age) & !is.na(value) & age <= 25) %>%
  mutate(age = mapvalues(age, age_orig, age_cat)) %>%
  #unite(item, item, age, sep = ".") %>%
  group_by(PROC_CID, item, age) %>%
  summarize(value = mean(value, na.rm = T)) %>%
  ungroup()

outcome_wide <- outcome_long %>%
  separate(item, c("item", "type")) %>%
  group_by(PROC_CID, item, age) %>%
  summarize(value = mean(value, na.rm = T)) %>%
  ungroup() %>%
  full_join(outcome_long) %>%
  unite(comb, item, age, sep = ".") %>%
  spread(key = comb, value = value) 

outcome_subs <- unique(as.character(outcome_wide$PROC_CID))
```

```{r}
head(outcome_wide)
```




#Multiple Imputation
We perform multiple imputation using the `mi` package. We use the variables we defined before in the `match_wide` data set. Before doing so, we first create a missing data frame and examine missingness patterns. Then we run the mi and save them to a list for use in propensity score weighting.  

###Pre-Work: Correlations
```{r}
r <- match_wide %>% select(-PROC_CID, -PROC_MID) %>% mutate_all(funs(as.numeric)) %>% cor(., use = "pairwise")

data.frame(r) %>% mutate(var = colnames(.)) %>%
  gather(key = var2, value = value, -var) %>%
  mutate(value = ifelse(var == var2, 0, value)) %>%
  ggplot(aes(x = var, y = var2, fill = value)) +
  geom_raster() +
  scale_fill_gradient2(low = "blue", mid = "white", high = "red",
                       limit = c(-1,1), midpoint = 0) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90)) 
```

#MI Procedure
```{r, eval = F}
# figure out which subjects have grouping, matching, predictor, and outcome data
subs <- match_subs[match_subs %in% group_subs]
subs <- subs[subs %in% pred_subs]
subs <- subs[subs %in% outcome_subs]

# keep only those people
match_wide   <- match_wide   %>% filter(PROC_CID %in% subs)
pred_long    <- pred_long    %>% filter(PROC_CID %in% subs)
outcome_wide <- outcome_wide %>% filter(PROC_CID %in% subs)

# get a list of all objects in teh environment and keep only those we need to MI and PSW
all_env <- ls()
all_env <- all_env[!(all_env %in% c("pred_long", "outcome_wide", "match_wide", 
                                    "dat", "child", "mom"))]
rm(list = all_env)

# MI doesn't like tibbles, so we need to unclass and reclass the data
match_wide <- data.frame(unclass(match_wide)) # mi doesn't like tibbles
nlsy.mdf <- missing_data.frame(data.frame(unclass(match_wide)))
# save.image(paste(data_path"data/all_data2.RData", sep = "/"))
# load(paste(data_path, "data/all_data.RData", sep = "/"))

image(nlsy.mdf)
```

\newpage
\blandscape
```{r, fig.height = 6.5, fig.width = 9, echo = F}
load(paste(data_path, "data/all_data.RData", sep = "/"))
# examine missingness before imputation
image(nlsy.mdf)
```

\elandscape
\newpage

```{r, eval = F}
# get descriptives of the data
des <- describe(match_wide,fast = T)
nlsy.mdf <- change(data = nlsy.mdf, y = rownames(des)[des$range >= 3],
                   what = "type", to = "continuous")
nlsy.mdf <- change(data = nlsy.mdf, y = c("DemPweight", "DemPheight"),
                   what = "type", to = "continuous")

nlsy.mi <- mi(nlsy.mdf, n.chains = n_cores, n.iter = 20, parallel = T)
image(nlsy.mi)
```

\newpage
\blandscape
```{r, fig.height = 6.5, fig.width = 9, echo = F}
image(nlsy.mi)
```
\elandscape
\newpage

```{r, eval = F}
completed.nlsy <- complete(nlsy.mi)
save(completed.nlsy, nlsy.mdf, nlsy.mi, file = paste(data_path, "results/mi_dat.RData", sep = "/"))

clean.mi.fun <- function(df, Chain){
  df <- tbl_df(df) %>% select(-contains("missing_"))
}

nested.mi <- 
  tibble(chain = paste("chain", 1:10, sep = "."), data = completed.nlsy) %>%
  mutate(imp.data = map2(data, chain, possibly(clean.mi.fun, NA_real_))) 
```


#Propensity Score Matching
Then, we perform propensity score weighting using our imputed datasets using the `twang` package. We then add the weights to our matching data frame, along with our predictor variables. To test the effectiveness of the propensity score weighting procedure, we examine the average standardized effect size in the balance tables. minimal effect sizes are candidates for beng dropped from the propensity score weighting, and large effect sizes mean our weighting procedure wasn't effective.  We can also examine these using balance plots.
```{r, eval = F}
# this function actually runs the propensity score weighting procedure
psw_fun <- function(df){
  to.match <- colnames(df)[-which(colnames(df) %in% c("PROC_CID","PROC_MID","groups"))]
  match.formula <- as.formula(paste("groups ~ ", paste(to.match, collapse=" + "), sep = " "))
  y <- mnps(formula = match.formula,
            data=df,
            n.trees=3000,
            stop.method = "es.mean")
}

# changing the data fed into psw into a data frame because it won't work with tibbles
psw_df <- function(psw){psw$data <- data.frame(psw$data); psw}

# once weighting is done, we pull the weights back into the original mi df
# and join back with the df of personality variables
add_psw_weights <- function(psw, df){
  df$weights <- get.weights(psw)
  df <- df %>%
    mutate(groups = relevel(df$groups, "Jail")) %>%
  full_join(pred_long, .drop = T)
  return(df)
}

# this function creates the balance table of the psw weights and filters 
# the results into variables the matching procedure did not fix and 
# those that it did
unbalanced_fun <- function(psw){
  x <- bal.table(psw)
  y <- x %>% 
    filter(stop.method == "es.mean" | stop.method == "unw") %>% 
    select(stop.method, tmt1, tmt2, var, std.eff.sz) %>%
    group_by(stop.method, tmt1, tmt2, var) %>%
    summarize(m.eff = mean(std.eff.sz)) %>%
    filter((stop.method == "es.mean" & m.eff >= .2) |
           (stop.method == "unw" & m.eff <= .05)) %>%
    setNames(c("stop.method", "Group1", "Group2", "Variable", "Average Standardized Effect"))
  unbalanced.var <- tbl_df(y) %>% filter(stop.method == "es.mean") %>% select(-stop.method)
  smalldiff.var <- tbl_df(y) %>% filter(stop.method == "unw") %>% select(-stop.method)
  return(list(unbalanced = unbalanced.var,smalldiff = smalldiff.var))
}


grab_fun <- function(tab, type){
  if(type == "unbalanced"){tab$unbalanced}
  else{tab$smalldiff}
}

nested.psw <- nested.mi %>%
  mutate(psw = map(imp.data, possibly(psw_fun, NA_real_)),
         psw = map(psw, possibly(psw_df, NA_real_)),
         imp.data = map2(psw, imp.data, possibly(add_psw_weights, NA_real_)),
         bal.tab = map(psw, possibly(unbalanced_fun,  NA_real_)),
         unbal.tab = map(bal.tab, possibly(~grab_fun(., "unbalanced"), NA_real_)),
         smalldiff.tab = map(bal.tab, possibly(~grab_fun(., "smalldiff"), NA_real_))) 

# clear up the environment
all_env <- ls()
all_env <- all_env[!(all_env %in% c("pred_long", "outcome_wide", "match_wide", 
                                    "dat", "child", "mom", "nlsy.mdf", "nested.mi",
                                    "nested.psw", "completed.nlsy", "nlsy.mi"))]
rm(list = all_env)

save.image(paste(data_path, "data/all_data.RData", sep = "/"))
```

##Balance Tables
"Having estimated the propensity scores, bal.table() produces a table that shows how well the resulting weights succeed in manipulating the control group so that its weighted pretreatment characteristics match, or balance, those of the unweighted treatment group if estimand = "ATT" or the control and treatment groups so that the weighted pretreatment characteristics match, or balance, with one another if estimand = "ATE"." (quote from the `twang` package tutorial)   
```{r, message = F, warning = F, results = 'asis'}
unbal.tab <- nested.psw %>% 
  unnest(unbal.tab) %>% 
  group_by(Group1, Group2, Variable) %>% 
  summarize(`Average Standardized Effect` = mean(`Average Standardized Effect`, na.rm = T)) 
unbal.xtab <- xtable(unbal.tab, caption = "Unbalanced Variables after Propensity Score Weighting")
print(unbal.xtab, tabular.environment = "longtable", floating = F, include.rownames = F)
  
smalldiff.tab <- nested.psw %>% 
  unnest(smalldiff.tab) %>% 
  group_by(Group1, Group2, Variable) %>% 
  summarize(`Average Standardized Effect` = mean(`Average Standardized Effect`, na.rm = T))
smalldiff.xtab <- xtable(smalldiff.tab, caption = "Balanced Variables after Propensity Score Weighting")
print(smalldiff.xtab, tabular.environment = "longtable", floating = F, include.rownames = F)
```


##Balance Plots
In these plots, substantial reductions in effect sizes are observed for most variables (blue lines), with only one variable showing an increase in effect size (red lines), but only a seemingly trivial increase. Closed red circles indicate a statistically significant difference, many of which occur before weighting, none after.
```{r, eval = F}
print_plot_fun <- function(p, Chain){
  p$main <- sprintf("Imputed dataset %s", gsub("chain.", "", Chain))
  p
}
par(mfrow = c(2,5))
nested.psw <- nested.psw %>% 
  mutate(plots = map(psw, possibly(~plot(., plots = "es"), NA_real_)),
         plots = map2(plots, chain, possibly(print_plot_fun, NA_real_)))
```


```{r, fig.height = 9, fig.width = 6.5}
plots <- nested.psw$plots

do.call("grid.arrange", args = list(grobs = plots[1:6], nrow = 3))
```

```{r, fig.height = 6, fig.width = 6.5}
do.call("grid.arrange", args = list(grobs = plots[7:10], nrow = 2))
```


#Growth Models
##Unweighted

##Weighted
```{r, eval = F}

nested.mods <- nested.psw %>%
  unnest(imp.data) %>%
  group_by(chain, item) %>%
  nest() %>%
  filter(!(is.na(chain) | is.na(item))) 

imp.list <- lapply(unique(nested.mods$item),  function(it){(nested.mods %>% filter(item == it))$data})
imp.list <- lapply(imp.list, function(li){mitools::imputationList(li)})
svy.df_imp <- lapply(imp.list, function(df){survey::svydesign(id=~1, weights = weights, data = df})

mod_form <- as.formula("value ~ age0 + groups + age0*groups + (age0 | PROC_CID)")

lmer_fun <- function(df){
  y <- lmer(value ~ age0 + groups + age0*groups + (age0 | PROC_CID), 
            weights = weights, data = df)
}

nested.mods <- nested.psw %>%
  unnest(imp.data) %>%
  group_by(chain, item) %>%
  nest() %>%
  filter(!(is.na(chain) | is.na(item))) %>%
  mutate(mod = map(data, possibly(lmer_fun, NA_real_)))

Imp.list  <- MIcombine((nested.mods %>% filter(item == "Imp"))$mod)
SS.list   <- MIcombine((nested.mods %>% filter(item == "SenS"))$mod)
CESD.list <- MIcombine((nested.mods %>% filter(item == "CESD"))$mod)
SE.lsit   <- MIcombine((nested.mods %>% filter(item == "SE"))$mod)
```


#Variability and Outcomes